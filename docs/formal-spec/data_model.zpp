(*===========================================================================*)
(* Z++ Formal Specification: NPU Data Model                                  *)
(* Repository: o9nn/npu                                                       *)
(* Description: Formalization of the data layer for the NPU Virtual PCB      *)
(*             architecture, including memory regions, GPIO pins, device     *)
(*             drivers, and peripheral state.                                 *)
(*===========================================================================*)

(*---------------------------------------------------------------------------*)
(* Base Types                                                                 *)
(*---------------------------------------------------------------------------*)

[DEVICE_ID]     (* Unique identifier for virtual devices *)
[MODEL_PATH]    (* Path to GGUF model files *)
[ACCOUNT_CODE]  (* Financial account code (e.g., "1101") *)
[ERROR_CODE]    (* System error codes *)

(* Memory address space *)
ADDRESS == ‚Ñï

(* Device states enumeration *)
DEVICE_STATE ::= uninitialized | initializing | ready | running | sleeping | error | shutdown

(* GPIO pin modes *)
PIN_MODE ::= input | output | analog | pwm | interrupt

(* GPIO pin states *)
PIN_STATE ::= low | high | tristate

(* Interrupt types *)
INTERRUPT_TYPE ::= edge_rising | edge_falling | level_high | level_low

(* Memory region types *)
REGION_TYPE ::= sram | flash | peripheral

(*---------------------------------------------------------------------------*)
(* Memory Region Schema                                                       *)
(*---------------------------------------------------------------------------*)

(* Represents a contiguous region of addressable memory *)
MemoryRegion
  base_address : ADDRESS
  size : ‚Ñï‚ÇÅ                  (* Size must be positive *)
  name : seq CHAR
  region_type : REGION_TYPE
  is_writable : ùîπ
  data : ADDRESS ‚á∏ ‚Ñï        (* Partial function: address to byte value *)

where
  (* All addresses within region are bounded *)
  dom data ‚äÜ base_address .. (base_address + size - 1) ‚àß
  
  (* All byte values are valid (0-255) *)
  (‚àÄ addr : dom data ‚Ä¢ data(addr) ‚â§ 255) ‚àß
  
  (* Write protection invariant *)
  (¬¨ is_writable ‚áí data = ‚àÖ)

(* Specific memory regions defined by address ranges *)
SRAM_BASE : ADDRESS
SRAM_SIZE : ‚Ñï‚ÇÅ
FLASH_BASE : ADDRESS
FLASH_SIZE : ‚Ñï‚ÇÅ
PERIPH_BASE : ADDRESS
PERIPH_SIZE : ‚Ñï‚ÇÅ

where
  SRAM_BASE = 0x20000000 ‚àß
  SRAM_SIZE = 262144 ‚àß         (* 256 KB *)
  FLASH_BASE = 0x08000000 ‚àß
  FLASH_SIZE = 1048576 ‚àß       (* 1 MB *)
  PERIPH_BASE = 0x40000000 ‚àß
  PERIPH_SIZE = 65536          (* 64 KB *)

(*---------------------------------------------------------------------------*)
(* GPIO Pin Schema                                                            *)
(*---------------------------------------------------------------------------*)

(* Represents a single General Purpose I/O pin *)
GPIOPin
  pin_number : ‚Ñï
  mode : PIN_MODE
  state : PIN_STATE
  analog_value : ‚Ñï           (* 12-bit ADC: 0-4095 *)
  interrupt_enabled : ùîπ
  interrupt_vector : ‚Ñï

where
  (* Pin number is valid (64 GPIO pins total) *)
  pin_number < 64 ‚àß
  
  (* Analog value is within 12-bit range *)
  analog_value ‚â§ 4095 ‚àß
  
  (* Interrupt vector is valid when interrupts enabled *)
  (interrupt_enabled ‚áí interrupt_vector < 256) ‚àß
  
  (* Analog mode implies specific value constraints *)
  (mode = analog ‚áí state = tristate)

(* GPIO Pin Bank - collection of 64 pins *)
GPIOPinBank
  pins : ‚Ñï ‚á∏ GPIOPin

where
  (* Exactly 64 pins *)
  dom pins = 0 .. 63 ‚àß
  
  (* Each pin has unique number matching its index *)
  (‚àÄ i : dom pins ‚Ä¢ pins(i).pin_number = i)

(*---------------------------------------------------------------------------*)
(* Financial Account Pin Mapping                                              *)
(*---------------------------------------------------------------------------*)

(* Maps financial account codes to GPIO pins *)
AccountPin
  account_code : ACCOUNT_CODE
  pin_number : ‚Ñï
  balance_voltage : ‚Ñù        (* Balance mapped to voltage *)
  is_active : ùîπ

where
  (* Pin number is valid *)
  pin_number < 64 ‚àß
  
  (* Voltage is within valid range (0-3.3V) *)
  balance_voltage ‚â• 0 ‚àß balance_voltage ‚â§ 3.3 ‚àß
  
  (* Active pins have non-zero voltage *)
  (is_active ‚áí balance_voltage > 0)

(* Financial account categories mapped to pin ranges *)
ASSET_PIN_RANGE : ‚Ñô ‚Ñï
LIABILITY_PIN_RANGE : ‚Ñô ‚Ñï
EQUITY_PIN_RANGE : ‚Ñô ‚Ñï
REVENUE_PIN_RANGE : ‚Ñô ‚Ñï
EXPENSE_PIN_RANGE : ‚Ñô ‚Ñï

where
  ASSET_PIN_RANGE = 0 .. 15 ‚àß
  LIABILITY_PIN_RANGE = 16 .. 31 ‚àß
  EQUITY_PIN_RANGE = 32 .. 39 ‚àß
  REVENUE_PIN_RANGE = 40 .. 47 ‚àß
  EXPENSE_PIN_RANGE = 48 .. 63 ‚àß
  
  (* Ranges are disjoint and cover all 64 pins *)
  ASSET_PIN_RANGE ‚à© LIABILITY_PIN_RANGE = ‚àÖ ‚àß
  ASSET_PIN_RANGE ‚à© EQUITY_PIN_RANGE = ‚àÖ ‚àß
  ASSET_PIN_RANGE ‚à© REVENUE_PIN_RANGE = ‚àÖ ‚àß
  ASSET_PIN_RANGE ‚à© EXPENSE_PIN_RANGE = ‚àÖ ‚àß
  LIABILITY_PIN_RANGE ‚à© EQUITY_PIN_RANGE = ‚àÖ ‚àß
  LIABILITY_PIN_RANGE ‚à© REVENUE_PIN_RANGE = ‚àÖ ‚àß
  LIABILITY_PIN_RANGE ‚à© EXPENSE_PIN_RANGE = ‚àÖ ‚àß
  EQUITY_PIN_RANGE ‚à© REVENUE_PIN_RANGE = ‚àÖ ‚àß
  EQUITY_PIN_RANGE ‚à© EXPENSE_PIN_RANGE = ‚àÖ ‚àß
  REVENUE_PIN_RANGE ‚à© EXPENSE_PIN_RANGE = ‚àÖ ‚àß
  
  ASSET_PIN_RANGE ‚à™ LIABILITY_PIN_RANGE ‚à™ EQUITY_PIN_RANGE ‚à™ 
    REVENUE_PIN_RANGE ‚à™ EXPENSE_PIN_RANGE = 0 .. 63

(*---------------------------------------------------------------------------*)
(* DMA (Direct Memory Access) Schema                                          *)
(*---------------------------------------------------------------------------*)

(* Represents a DMA transfer operation *)
DMATransfer
  channel_id : ‚Ñï
  source_address : ADDRESS
  dest_address : ADDRESS
  length : ‚Ñï‚ÇÅ
  completed : ùîπ
  start_time : ‚Ñï            (* Timestamp in microseconds *)

where
  (* Channel ID is valid (8 DMA channels) *)
  channel_id < 8 ‚àß
  
  (* Source and destination don't overlap *)
  source_address + length ‚â§ dest_address ‚à® 
  dest_address + length ‚â§ source_address

(* DMA Controller manages multiple transfers *)
DMAController
  active_transfers : ‚Ñï ‚á∏ DMATransfer
  max_channels : ‚Ñï‚ÇÅ

where
  max_channels = 8 ‚àß
  
  (* Number of active transfers doesn't exceed max channels *)
  #active_transfers ‚â§ max_channels ‚àß
  
  (* Channel IDs are unique and valid *)
  dom active_transfers ‚äÜ 0 .. (max_channels - 1) ‚àß
  
  (* Each transfer has matching channel ID *)
  (‚àÄ ch : dom active_transfers ‚Ä¢ active_transfers(ch).channel_id = ch)

(*---------------------------------------------------------------------------*)
(* Interrupt Controller Schema                                                *)
(*---------------------------------------------------------------------------*)

(* Interrupt descriptor with priority and type *)
InterruptDescriptor
  vector : ‚Ñï
  int_type : INTERRUPT_TYPE
  priority : ‚Ñï              (* Higher number = higher priority *)
  enabled : ùîπ
  pending : ùîπ

where
  (* Vector number is valid (256 interrupt vectors) *)
  vector < 256 ‚àß
  
  (* Priority is within valid range (0-15) *)
  priority ‚â§ 15 ‚àß
  
  (* Cannot be pending if not enabled *)
  (pending ‚áí enabled)

(* Interrupt Controller manages interrupt vectors *)
InterruptController
  interrupt_table : ‚Ñï ‚á∏ InterruptDescriptor
  pending_queue : seq ‚Ñï     (* Queue of pending interrupt vectors *)
  max_vectors : ‚Ñï‚ÇÅ

where
  max_vectors = 256 ‚àß
  
  (* Interrupt table has entries for all vectors *)
  dom interrupt_table = 0 .. (max_vectors - 1) ‚àß
  
  (* Each descriptor has matching vector number *)
  (‚àÄ v : dom interrupt_table ‚Ä¢ interrupt_table(v).vector = v) ‚àß
  
  (* Pending queue contains only valid, enabled, pending interrupts *)
  (‚àÄ i : 1 .. #pending_queue ‚Ä¢ 
    pending_queue(i) ‚àà dom interrupt_table ‚àß
    interrupt_table(pending_queue(i)).enabled ‚àß
    interrupt_table(pending_queue(i)).pending) ‚àß
  
  (* No duplicate vectors in pending queue *)
  (‚àÄ i, j : 1 .. #pending_queue ‚Ä¢ i ‚â† j ‚áí pending_queue(i) ‚â† pending_queue(j))

(*---------------------------------------------------------------------------*)
(* Power Management Schema                                                     *)
(*---------------------------------------------------------------------------*)

(* Power rail identifier *)
RAIL_ID ::= rail_3v3 | rail_5v0

(* Power management state *)
PowerManagement
  voltage_rails : RAIL_ID ‚á∏ ‚Ñù
  current_draw : RAIL_ID ‚á∏ ‚Ñù
  temperature_celsius : ‚Ñù

where
  (* Voltage rails have correct nominal values *)
  voltage_rails(rail_3v3) ‚â• 3.2 ‚àß voltage_rails(rail_3v3) ‚â§ 3.4 ‚àß
  voltage_rails(rail_5v0) ‚â• 4.9 ‚àß voltage_rails(rail_5v0) ‚â§ 5.1 ‚àß
  
  (* Current draw is non-negative *)
  (‚àÄ rail : dom current_draw ‚Ä¢ current_draw(rail) ‚â• 0) ‚àß
  
  (* Temperature is within operating range *)
  temperature_celsius ‚â• -40 ‚àß temperature_celsius ‚â§ 85

(*---------------------------------------------------------------------------*)
(* LLM Hardware Registers                                                      *)
(*---------------------------------------------------------------------------*)

(* LLM coprocessor register offsets *)
LLM_REG_BASE : ADDRESS
LLM_REG_CMD : ADDRESS
LLM_REG_STATUS : ADDRESS
LLM_REG_PROMPT_ADDR : ADDRESS
LLM_REG_PROMPT_LEN : ADDRESS
LLM_REG_N_PREDICT : ADDRESS
LLM_REG_TOKEN_OUT : ADDRESS
LLM_REG_TOKEN_READY : ADDRESS
LLM_REG_MODEL_ID : ADDRESS
LLM_REG_CTX_USED : ADDRESS
LLM_REG_ERROR_CODE : ADDRESS
LLM_REG_PERF_TOKENS_SEC : ADDRESS

where
  LLM_REG_BASE = PERIPH_BASE + 0x1000 ‚àß
  LLM_REG_CMD = LLM_REG_BASE + 0x00 ‚àß
  LLM_REG_STATUS = LLM_REG_BASE + 0x04 ‚àß
  LLM_REG_PROMPT_ADDR = LLM_REG_BASE + 0x08 ‚àß
  LLM_REG_PROMPT_LEN = LLM_REG_BASE + 0x0C ‚àß
  LLM_REG_N_PREDICT = LLM_REG_BASE + 0x10 ‚àß
  LLM_REG_TOKEN_OUT = LLM_REG_BASE + 0x14 ‚àß
  LLM_REG_TOKEN_READY = LLM_REG_BASE + 0x18 ‚àß
  LLM_REG_MODEL_ID = LLM_REG_BASE + 0x1C ‚àß
  LLM_REG_CTX_USED = LLM_REG_BASE + 0x20 ‚àß
  LLM_REG_ERROR_CODE = LLM_REG_BASE + 0x24 ‚àß
  LLM_REG_PERF_TOKENS_SEC = LLM_REG_BASE + 0x28

(* Command register bits *)
CMD_BIT_RESET : ‚Ñï
CMD_BIT_LOAD_MODEL : ‚Ñï
CMD_BIT_START_INF : ‚Ñï
CMD_BIT_SOFT_STOP : ‚Ñï

where
  CMD_BIT_RESET = 0 ‚àß
  CMD_BIT_LOAD_MODEL = 1 ‚àß
  CMD_BIT_START_INF = 2 ‚àß
  CMD_BIT_SOFT_STOP = 3

(* Status register bits *)
STATUS_BIT_IDLE : ‚Ñï
STATUS_BIT_BUSY : ‚Ñï
STATUS_BIT_EOG : ‚Ñï
STATUS_BIT_ERROR : ‚Ñï
STATUS_BIT_MODEL_READY : ‚Ñï
STATUS_BIT_TOKEN_READY : ‚Ñï

where
  STATUS_BIT_IDLE = 0 ‚àß
  STATUS_BIT_BUSY = 1 ‚àß
  STATUS_BIT_EOG = 2 ‚àß
  STATUS_BIT_ERROR = 3 ‚àß
  STATUS_BIT_MODEL_READY = 4 ‚àß
  STATUS_BIT_TOKEN_READY = 5

(*---------------------------------------------------------------------------*)
(* LLM Model Configuration                                                     *)
(*---------------------------------------------------------------------------*)

(* Configuration parameters for LLM models *)
LlamaModelConfig
  model_path : MODEL_PATH
  model_name : seq CHAR
  n_ctx : ‚Ñï‚ÇÅ                (* Context window size *)
  n_threads : ‚Ñï‚ÇÅ            (* CPU threads *)
  n_gpu_layers : ‚Ñï          (* GPU layers (0 = CPU only) *)
  batch_size : ‚Ñï‚ÇÅ
  offload_kv_cache : ùîπ
  low_vram_mode : ùîπ

where
  (* Context size is reasonable (512 to 32768) *)
  n_ctx ‚â• 512 ‚àß n_ctx ‚â§ 32768 ‚àß
  
  (* Thread count is reasonable (1 to 64) *)
  n_threads ‚â• 1 ‚àß n_threads ‚â§ 64 ‚àß
  
  (* GPU layers is non-negative *)
  n_gpu_layers ‚â• 0 ‚àß
  
  (* Batch size is reasonable (1 to 512) *)
  batch_size ‚â• 1 ‚àß batch_size ‚â§ 512

(* Sequence generation configuration *)
LlamaSequenceConfig
  n_predict : ‚Ñï‚ÇÅ            (* Tokens to generate *)
  max_ctx : ‚Ñï‚ÇÅ              (* Maximum context *)
  echo_prompt : ùîπ
  stream_tokens : ùîπ
  stream_delay_ms : ‚Ñï

where
  (* Predict count is reasonable (1 to 2048) *)
  n_predict ‚â• 1 ‚àß n_predict ‚â§ 2048 ‚àß
  
  (* Max context is reasonable *)
  max_ctx ‚â• 512 ‚àß max_ctx ‚â§ 32768 ‚àß
  
  (* Stream delay is reasonable (0 to 1000ms) *)
  stream_delay_ms ‚â§ 1000

(* Telemetry data for LLM operations *)
LlamaTelemetry
  tokens_per_second : ‚Ñù
  total_tokens_generated : ‚Ñï
  total_prompts : ‚Ñï
  last_prompt_tokens : ‚Ñï
  last_completion_tokens : ‚Ñï

where
  (* Tokens per second is non-negative *)
  tokens_per_second ‚â• 0 ‚àß
  
  (* Total tokens is sum of all completions *)
  total_tokens_generated ‚â• last_completion_tokens ‚àß
  
  (* Total prompts is positive if tokens generated *)
  (total_tokens_generated > 0 ‚áí total_prompts > 0)

(*---------------------------------------------------------------------------*)
(* Financial Device Registers                                                 *)
(*---------------------------------------------------------------------------*)

(* Financial device register offsets *)
FIN_REG_BASE : ADDRESS
FIN_REG_TRANSACTION_STATUS : ADDRESS
FIN_REG_BALANCE_TOTAL : ADDRESS
FIN_REG_TRANSACTION_COUNT : ADDRESS
FIN_REG_ERROR_CODE : ADDRESS

where
  FIN_REG_BASE = PERIPH_BASE + 0x0000 ‚àß
  FIN_REG_TRANSACTION_STATUS = FIN_REG_BASE + 0x00 ‚àß
  FIN_REG_BALANCE_TOTAL = FIN_REG_BASE + 0x04 ‚àß
  FIN_REG_TRANSACTION_COUNT = FIN_REG_BASE + 0x08 ‚àß
  FIN_REG_ERROR_CODE = FIN_REG_BASE + 0x0C

(*---------------------------------------------------------------------------*)
(* Device Driver Base Schema                                                  *)
(*---------------------------------------------------------------------------*)

(* Abstract device driver interface *)
DeviceDriver
  driver_name : seq CHAR
  version : seq CHAR
  is_loaded : ùîπ
  is_initialized : ùîπ

where
  (* Driver must be loaded before initialization *)
  (is_initialized ‚áí is_loaded) ‚àß
  
  (* Driver name is non-empty *)
  #driver_name > 0

(*---------------------------------------------------------------------------*)
(* Financial Device Driver Schema                                             *)
(*---------------------------------------------------------------------------*)

FinancialDeviceDriver
  DeviceDriver                  (* Inherits base driver schema *)
  account_pins : ACCOUNT_CODE ‚á∏ AccountPin
  transaction_count : ‚Ñï
  total_balance : ‚Ñù

where
  (* Account codes map to unique pins *)
  (‚àÄ a1, a2 : dom account_pins ‚Ä¢ 
    a1 ‚â† a2 ‚áí account_pins(a1).pin_number ‚â† account_pins(a2).pin_number) ‚àß
  
  (* Total balance is sum of all account balances *)
  total_balance ‚â• 0 ‚àß
  
  (* Transaction count is non-negative *)
  transaction_count ‚â• 0

(*---------------------------------------------------------------------------*)
(* LLM Coprocessor Driver Schema                                              *)
(*---------------------------------------------------------------------------*)

LlamaCoprocessorDriver
  DeviceDriver                  (* Inherits base driver schema *)
  model_config : LlamaModelConfig
  telemetry : LlamaTelemetry
  model_id : ‚Ñï
  model_loaded : ùîπ
  inference_active : ùîπ

where
  (* Model must be loaded before inference *)
  (inference_active ‚áí model_loaded) ‚àß
  
  (* Model ID is non-zero when loaded *)
  (model_loaded ‚áí model_id > 0) ‚àß
  
  (* Driver must be initialized if model loaded *)
  (model_loaded ‚áí is_initialized)

(*===========================================================================*)
(* End of Data Model Specification                                           *)
(*===========================================================================*)

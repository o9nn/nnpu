(*===========================================================================*)
(* Z++ Formal Specification: NPU External Integrations                       *)
(* Repository: o9nn/npu                                                       *)
(* Description: Formalization of external integration contracts for the NPU *)
(*             system, including GGUF runtime, I/O streams, and external     *)
(*             data sources.                                                  *)
(*===========================================================================*)

(*---------------------------------------------------------------------------*)
(* Import Base Specifications                                                 *)
(*---------------------------------------------------------------------------*)

(* This specification builds upon all previous specifications *)
(* Assumed: All types, schemas, states, and operations are in scope *)

(*---------------------------------------------------------------------------*)
(* GGUF Runtime Integration                                                   *)
(*---------------------------------------------------------------------------*)

[TOKEN_ID]      (* Token identifier from tokenizer *)
[MODEL_HANDLE]  (* Opaque handle to loaded GGUF model *)
[CONTEXT_HANDLE] (* Opaque handle to inference context *)

(* GGUF model parameters *)
GGUFModelParams
  n_ctx : ‚Ñï‚ÇÅ
  n_batch : ‚Ñï‚ÇÅ
  n_threads : ‚Ñï‚ÇÅ
  n_gpu_layers : ‚Ñï
  use_mmap : ùîπ
  use_mlock : ùîπ
  vocab_only : ùîπ
  rope_freq_base : ‚Ñù
  rope_freq_scale : ‚Ñù

where
  (* Context size constraints *)
  n_ctx ‚â• 512 ‚àß n_ctx ‚â§ 32768 ‚àß
  
  (* Batch size constraints *)
  n_batch ‚â• 1 ‚àß n_batch ‚â§ 512 ‚àß
  
  (* Thread count constraints *)
  n_threads ‚â• 1 ‚àß n_threads ‚â§ 64 ‚àß
  
  (* RoPE (Rotary Position Embedding) parameters *)
  rope_freq_base > 0 ‚àß
  rope_freq_scale > 0

(* GGUF context parameters *)
GGUFContextParams
  seed : ‚Ñï
  n_ctx : ‚Ñï‚ÇÅ
  n_batch : ‚Ñï‚ÇÅ
  n_threads : ‚Ñï‚ÇÅ
  n_threads_batch : ‚Ñï‚ÇÅ

where
  n_ctx ‚â• 512 ‚àß n_ctx ‚â§ 32768 ‚àß
  n_batch ‚â• 1 ‚àß n_batch ‚â§ 512 ‚àß
  n_threads ‚â• 1 ‚àß n_threads ‚â§ 64 ‚àß
  n_threads_batch ‚â• 1 ‚àß n_threads_batch ‚â§ 64

(* External GGUF runtime state *)
GGUFRuntimeState
  model_handle : MODEL_HANDLE
  context_handle : CONTEXT_HANDLE
  model_params : GGUFModelParams
  context_params : GGUFContextParams
  model_loaded : ùîπ
  context_initialized : ùîπ

where
  (* Context requires loaded model *)
  context_initialized ‚áí model_loaded ‚àß
  
  (* Parameters must be consistent *)
  (model_loaded ‚àß context_initialized ‚áí
    model_params.n_ctx = context_params.n_ctx)

(* Load GGUF model from file *)
GGUFLoadModel
  ŒîGGUFRuntimeState
  model_path? : MODEL_PATH
  params? : GGUFModelParams
  success! : ùîπ
  error_msg! : seq CHAR

where
  (* Preconditions *)
  ¬¨model_loaded ‚àß
  
  (* Post-conditions on success *)
  (success! = true ‚áí
    model_loaded' = true ‚àß
    model_params' = params? ‚àß
    model_handle' ‚â† ‚àÖ ‚àß
    error_msg! = ‚ü®‚ü©) ‚àß
  
  (* Post-conditions on failure *)
  (success! = false ‚áí
    model_loaded' = false ‚àß
    #error_msg! > 0)

(* Initialize inference context *)
GGUFInitContext
  ŒîGGUFRuntimeState
  params? : GGUFContextParams
  success! : ùîπ
  error_msg! : seq CHAR

where
  (* Preconditions *)
  model_loaded ‚àß
  ¬¨context_initialized ‚àß
  
  (* Post-conditions on success *)
  (success! = true ‚áí
    context_initialized' = true ‚àß
    context_params' = params? ‚àß
    context_handle' ‚â† ‚àÖ ‚àß
    error_msg! = ‚ü®‚ü©) ‚àß
  
  (* Post-conditions on failure *)
  (success! = false ‚áí
    context_initialized' = false ‚àß
    #error_msg! > 0)

(* Tokenize text input *)
GGUFTokenize
  ŒûGGUFRuntimeState
  text? : seq CHAR
  add_bos? : ùîπ
  tokens! : seq TOKEN_ID
  success! : ùîπ

where
  (* Preconditions *)
  model_loaded ‚àß
  #text? > 0 ‚àß
  
  (* Post-conditions on success *)
  (success! = true ‚áí
    #tokens! > 0 ‚àß
    (add_bos? ‚áí tokens!(1) = BOS_TOKEN)) ‚àß
  
  (* Post-conditions on failure *)
  (success! = false ‚áí
    tokens! = ‚ü®‚ü©)

where
  BOS_TOKEN : TOKEN_ID  (* Beginning-of-sequence token *)

(* Detokenize token sequence to text *)
GGUFDetokenize
  ŒûGGUFRuntimeState
  tokens? : seq TOKEN_ID
  text! : seq CHAR
  success! : ùîπ

where
  (* Preconditions *)
  model_loaded ‚àß
  #tokens? > 0 ‚àß
  
  (* Post-conditions on success *)
  (success! = true ‚áí
    #text! > 0) ‚àß
  
  (* Post-conditions on failure *)
  (success! = false ‚áí
    text! = ‚ü®‚ü©)

(* Decode tokens and update KV cache *)
GGUFDecode
  ŒîGGUFRuntimeState
  tokens? : seq TOKEN_ID
  n_past? : ‚Ñï
  success! : ùîπ

where
  (* Preconditions *)
  model_loaded ‚àß
  context_initialized ‚àß
  #tokens? > 0 ‚àß
  n_past? + #tokens? ‚â§ context_params.n_ctx ‚àß
  
  (* Post-conditions *)
  (success! = true ‚áí
    (* KV cache is updated - abstracted *) true) ‚àß
  
  (success! = false ‚áí
    (* No state change on failure *) true)

(* Sample next token from logits *)
GGUFSample
  ŒûGGUFRuntimeState
  temperature? : ‚Ñù
  top_k? : ‚Ñï
  top_p? : ‚Ñù
  repeat_penalty? : ‚Ñù
  previous_tokens? : seq TOKEN_ID
  token! : TOKEN_ID
  success! : ùîπ

where
  (* Preconditions *)
  context_initialized ‚àß
  temperature? > 0 ‚àß
  top_k? > 0 ‚àß
  top_p? > 0 ‚àß top_p? ‚â§ 1 ‚àß
  repeat_penalty? ‚â• 1 ‚àß
  
  (* Post-conditions on success *)
  (success! = true ‚áí
    token! ‚â† ‚àÖ) ‚àß
  
  (* Post-conditions on failure *)
  (success! = false ‚áí
    token! = ‚àÖ)

(* Free GGUF runtime resources *)
GGUFFreeRuntime
  ŒîGGUFRuntimeState

where
  (* Mark as unloaded *)
  model_loaded' = false ‚àß
  context_initialized' = false ‚àß
  model_handle' = ‚àÖ ‚àß
  context_handle' = ‚àÖ

(*---------------------------------------------------------------------------*)
(* I/O Stream Integration                                                     *)
(*---------------------------------------------------------------------------*)

[STREAM_HANDLE] (* Opaque handle to I/O stream *)
[DEVICE_PATH]   (* Path to device file *)

(* Stream status *)
STREAM_STATUS ::= stream_closed | stream_open | stream_error

(* UART configuration *)
UARTConfig
  baud_rate : ‚Ñï
  data_bits : ‚Ñï
  stop_bits : ‚Ñï
  parity : CHAR
  flow_control : ùîπ

where
  (* Valid baud rates *)
  baud_rate ‚àà {9600, 19200, 38400, 57600, 115200, 230400, 460800, 921600} ‚àß
  
  (* Valid data bits *)
  data_bits ‚àà {5, 6, 7, 8} ‚àß
  
  (* Valid stop bits *)
  stop_bits ‚àà {1, 2} ‚àß
  
  (* Valid parity *)
  parity ‚àà {'N', 'E', 'O', 'M', 'S'}

(* UART stream state *)
UARTStreamState
  device_path : DEVICE_PATH
  handle : STREAM_HANDLE
  config : UARTConfig
  status : STREAM_STATUS
  bytes_sent : ‚Ñï
  bytes_received : ‚Ñï

where
  (* Handle is valid when stream is open *)
  (status = stream_open ‚áî handle ‚â† ‚àÖ) ‚àß
  
  (* Counters are non-negative *)
  bytes_sent ‚â• 0 ‚àß
  bytes_received ‚â• 0

(* Open UART stream *)
UARTOpen
  ŒîUARTStreamState
  device? : DEVICE_PATH
  config? : UARTConfig
  success! : ùîπ
  error_msg! : seq CHAR

where
  (* Preconditions *)
  status = stream_closed ‚àß
  
  (* Post-conditions on success *)
  (success! = true ‚áí
    status' = stream_open ‚àß
    device_path' = device? ‚àß
    config' = config? ‚àß
    handle' ‚â† ‚àÖ ‚àß
    bytes_sent' = 0 ‚àß
    bytes_received' = 0 ‚àß
    error_msg! = ‚ü®‚ü©) ‚àß
  
  (* Post-conditions on failure *)
  (success! = false ‚áí
    status' = stream_error ‚àß
    #error_msg! > 0)

(* Send data over UART *)
UARTSend
  ŒîUARTStreamState
  data? : seq ‚Ñï
  bytes_sent! : ‚Ñï
  success! : ùîπ

where
  (* Preconditions *)
  status = stream_open ‚àß
  #data? > 0 ‚àß
  (‚àÄ b : 1 .. #data? ‚Ä¢ data?(b) ‚â§ 255) ‚àß
  
  (* Post-conditions on success *)
  (success! = true ‚áí
    bytes_sent! = #data? ‚àß
    bytes_sent' = bytes_sent + bytes_sent!) ‚àß
  
  (* Post-conditions on failure *)
  (success! = false ‚áí
    bytes_sent! = 0)

(* Receive data from UART *)
UARTReceive
  ŒîUARTStreamState
  max_bytes? : ‚Ñï
  timeout_ms? : ‚Ñï
  data! : seq ‚Ñï
  success! : ùîπ

where
  (* Preconditions *)
  status = stream_open ‚àß
  max_bytes? > 0 ‚àß
  
  (* Post-conditions on success *)
  (success! = true ‚áí
    #data! ‚â§ max_bytes? ‚àß
    (‚àÄ b : 1 .. #data! ‚Ä¢ data!(b) ‚â§ 255) ‚àß
    bytes_received' = bytes_received + #data!) ‚àß
  
  (* Post-conditions on failure or timeout *)
  (success! = false ‚áí
    data! = ‚ü®‚ü©)

(* Close UART stream *)
UARTClose
  ŒîUARTStreamState

where
  status' = stream_closed ‚àß
  handle' = ‚àÖ

(* SPI configuration *)
SPIConfig
  clock_speed : ‚Ñï
  mode : ‚Ñï
  bits_per_word : ‚Ñï
  lsb_first : ùîπ

where
  (* Valid clock speeds (Hz) *)
  clock_speed ‚â• 1000 ‚àß clock_speed ‚â§ 50000000 ‚àß
  
  (* Valid SPI modes *)
  mode ‚àà {0, 1, 2, 3} ‚àß
  
  (* Valid bits per word *)
  bits_per_word ‚àà {8, 16}

(* I2C configuration *)
I2CConfig
  address : ‚Ñï
  clock_speed : ‚Ñï
  addressing_mode : ‚Ñï

where
  (* Valid 7-bit or 10-bit address *)
  (addressing_mode = 7 ‚áí address < 128) ‚àß
  (addressing_mode = 10 ‚áí address < 1024) ‚àß
  
  (* Valid clock speeds *)
  clock_speed ‚àà {10000, 100000, 400000, 1000000, 3400000}

(*---------------------------------------------------------------------------*)
(* External Data Integration                                                  *)
(*---------------------------------------------------------------------------*)

(* Chart of Accounts JSON structure *)
ChartOfAccounts
  accounts : ACCOUNT_CODE ‚á∏ AccountDefinition
  version : seq CHAR
  last_modified : ‚Ñï

where
  (* Account codes are non-empty *)
  dom accounts ‚â† ‚àÖ ‚àß
  
  (* Version is non-empty *)
  #version > 0

AccountDefinition
  code : ACCOUNT_CODE
  name : seq CHAR
  account_type : ACCOUNT_TYPE
  parent_code : ACCOUNT_CODE ‚à™ {‚ä•}
  is_active : ùîπ
  normal_balance : BALANCE_TYPE

where
  (* Code and name are non-empty *)
  #code > 0 ‚àß
  #name > 0 ‚àß
  
  (* Parent code must be different from self *)
  (parent_code ‚â† ‚ä• ‚áí parent_code ‚â† code)

ACCOUNT_TYPE ::= asset | liability | equity | revenue | expense
BALANCE_TYPE ::= debit | credit

(* Load chart of accounts from JSON *)
LoadChartOfAccounts
  ŒîFinancialDeviceState
  json_path? : seq CHAR
  chart! : ChartOfAccounts
  success! : ùîπ
  error_msg! : seq CHAR

where
  (* Preconditions *)
  driver.is_initialized ‚àß
  #json_path? > 0 ‚àß
  
  (* Post-conditions on success *)
  (success! = true ‚áí
    #chart!.accounts > 0 ‚àß
    error_msg! = ‚ü®‚ü© ‚àß
    (* Map accounts to appropriate GPIO pin ranges *)
    (‚àÄ a : dom chart!.accounts ‚Ä¢
      let account == chart!.accounts(a) ‚Ä¢
      (account.account_type = asset ‚áí 
        ‚àÉ pin : ASSET_PIN_RANGE ‚Ä¢ 
          driver'.account_pins(a).pin_number = pin) ‚àß
      (account.account_type = liability ‚áí 
        ‚àÉ pin : LIABILITY_PIN_RANGE ‚Ä¢ 
          driver'.account_pins(a).pin_number = pin) ‚àß
      (account.account_type = equity ‚áí 
        ‚àÉ pin : EQUITY_PIN_RANGE ‚Ä¢ 
          driver'.account_pins(a).pin_number = pin) ‚àß
      (account.account_type = revenue ‚áí 
        ‚àÉ pin : REVENUE_PIN_RANGE ‚Ä¢ 
          driver'.account_pins(a).pin_number = pin) ‚àß
      (account.account_type = expense ‚áí 
        ‚àÉ pin : EXPENSE_PIN_RANGE ‚Ä¢ 
          driver'.account_pins(a).pin_number = pin))) ‚àß
  
  (* Post-conditions on failure *)
  (success! = false ‚áí
    chart!.accounts = ‚àÖ ‚àß
    #error_msg! > 0)

(*---------------------------------------------------------------------------*)
(* External API Contracts                                                     *)
(*---------------------------------------------------------------------------*)

(* Rate limiting for API calls *)
RateLimiter
  requests_per_second : ‚Ñï
  current_window_start : ‚Ñï
  current_window_count : ‚Ñï
  total_requests : ‚Ñï
  total_rate_limits : ‚Ñï

where
  requests_per_second > 0 ‚àß
  current_window_count ‚â§ requests_per_second ‚àß
  total_requests ‚â• total_rate_limits ‚àß
  total_rate_limits ‚â• 0

(* Check if API call is allowed *)
CheckRateLimit
  ŒîRateLimiter
  current_time? : ‚Ñï
  allowed! : ùîπ

where
  (* Reset window if expired *)
  (current_time? - current_window_start ‚â• 1000000 ‚áí
    current_window_start' = current_time? ‚àß
    current_window_count' = 0) ‚àß
  
  (* Check if within limit *)
  (current_window_count < requests_per_second ‚áí
    allowed! = true ‚àß
    current_window_count' = current_window_count + 1 ‚àß
    total_requests' = total_requests + 1) ‚àß
  
  (* Rate limit exceeded *)
  (current_window_count ‚â• requests_per_second ‚áí
    allowed! = false ‚àß
    total_rate_limits' = total_rate_limits + 1)

(* Retry logic with exponential backoff *)
RetryPolicy
  max_retries : ‚Ñï
  base_delay_ms : ‚Ñï
  max_delay_ms : ‚Ñï
  current_attempt : ‚Ñï

where
  max_retries > 0 ‚àß
  base_delay_ms > 0 ‚àß
  max_delay_ms ‚â• base_delay_ms ‚àß
  current_attempt ‚â§ max_retries

(* Calculate next retry delay *)
CalculateRetryDelay
  ŒûRetryPolicy
  delay_ms! : ‚Ñï

where
  (* Exponential backoff with cap *)
  let exponential_delay == base_delay_ms * (2 ^ current_attempt) ‚Ä¢
  delay_ms! = min(exponential_delay, max_delay_ms)

(*---------------------------------------------------------------------------*)
(* Integration Composition                                                    *)
(*---------------------------------------------------------------------------*)

(* Complete LLM inference with GGUF integration *)
LLMInferenceWithGGUF
  ŒîLLMCoprocessorState
  ŒîGGUFRuntimeState
  prompt? : seq CHAR
  sequence_config? : LlamaSequenceConfig
  completion! : seq CHAR
  success! : ùîπ

where
  (* Preconditions *)
  driver.model_loaded ‚àß
  gguf_runtime.model_loaded ‚àß
  gguf_runtime.context_initialized ‚àß
  #prompt? > 0 ‚àß
  
  (* Inference pipeline *)
  ‚àÉ tokens_in, tokens_out : seq TOKEN_ID; 
    tokenize_ok, decode_ok, sample_ok, detok_ok : ùîπ ‚Ä¢
  
  (* 1. Tokenize input *)
  GGUFTokenize[prompt?/text?, true/add_bos?, 
               tokens_in/tokens!, tokenize_ok/success!] ‚àß
  tokenize_ok = true ‚àß
  
  (* 2. Configure and start inference *)
  ConfigureInference[0/prompt_addr?, #tokens_in/prompt_len?,
                    sequence_config?.n_predict/n_predict?] ‚àß
  StartInference ‚àß
  
  (* 3. Token generation loop *)
  (‚àÄ i : 1 .. sequence_config?.n_predict ‚Ä¢
    GGUFDecode[‚ü®tokens_in(i)‚ü©/tokens?, i-1/n_past?, decode_ok/success!] ‚àß
    decode_ok = true ‚àß
    GGUFSample[1.0/temperature?, 40/top_k?, 0.95/top_p?, 
               1.1/repeat_penalty?, tokens_out/previous_tokens?,
               sample_ok/success!] ‚àß
    sample_ok = true ‚àß
    tokens_out' = tokens_out ‚å¢ ‚ü®token!‚ü©) ‚àß
  
  (* 4. Detokenize output *)
  GGUFDetokenize[tokens_out/tokens?, completion!/text!, detok_ok/success!] ‚àß
  detok_ok = true ‚àß
  
  (* 5. Complete inference *)
  CompleteInference[completion!/completion_text!] ‚àß
  
  success! = (tokenize_ok ‚àß decode_ok ‚àß sample_ok ‚àß detok_ok)

(* Financial transaction with external validation *)
ValidatedFinancialTransaction
  ŒîFinancialDeviceState
  debit_account? : ACCOUNT_CODE
  credit_account? : ACCOUNT_CODE
  amount? : ‚Ñù
  description? : seq CHAR
  success! : ùîπ
  error_msg! : seq CHAR

where
  (* Preconditions *)
  driver.is_initialized ‚àß
  debit_account? ‚àà dom driver.account_pins ‚àß
  credit_account? ‚àà dom driver.account_pins ‚àß
  debit_account? ‚â† credit_account? ‚àß
  amount? > 0 ‚àß
  #description? > 0 ‚àß
  
  (* Double-entry accounting: debit one account, credit another *)
  ‚àÉ debit_balance, credit_balance : ‚Ñù ‚Ä¢
  
  (* Read current balances *)
  ReadAccountBalance[debit_account?/account_code?, 
                    debit_balance/balance!] ‚àß
  ReadAccountBalance[credit_account?/account_code?, 
                    credit_balance/balance!] ‚àß
  
  (* Update debit account *)
  UpdateAccountBalance[debit_account?/account_code?, 
                      debit_balance + amount?/balance?] ‚àß
  
  (* Update credit account *)
  UpdateAccountBalance[credit_account?/account_code?, 
                      credit_balance + amount?/balance?] ‚àß
  
  (* Verify accounting equation still holds *)
  let total_debits == Œ£{a : dom driver'.account_pins | 
                        a ‚àà ASSET_PIN_RANGE ‚à® a ‚àà EXPENSE_PIN_RANGE ‚Ä¢
                        driver'.account_pins(a).balance_voltage} ‚Ä¢
  let total_credits == Œ£{a : dom driver'.account_pins | 
                        a ‚àà LIABILITY_PIN_RANGE ‚à® a ‚àà EQUITY_PIN_RANGE ‚à®
                        a ‚àà REVENUE_PIN_RANGE ‚Ä¢
                        driver'.account_pins(a).balance_voltage} ‚Ä¢
  
  (total_debits = total_credits ‚áí
    success! = true ‚àß
    error_msg! = ‚ü®‚ü©) ‚àß
  
  (total_debits ‚â† total_credits ‚áí
    success! = false ‚àß
    error_msg! = "Accounting equation violated")

(*===========================================================================*)
(* End of Integrations Specification                                         *)
(*===========================================================================*)

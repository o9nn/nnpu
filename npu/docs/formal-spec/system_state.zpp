(*===========================================================================*)
(* Z++ Formal Specification: NPU System State                                *)
(* Repository: o9nn/npu                                                       *)
(* Description: Formalization of the complete system state for the NPU       *)
(*             Virtual PCB architecture, integrating all hardware components *)
(*             and device drivers into a coherent state model.                *)
(*===========================================================================*)

(*---------------------------------------------------------------------------*)
(* Import Base Data Model                                                     *)
(*---------------------------------------------------------------------------*)

(* This specification builds upon data_model.zpp *)
(* Assumed: All types and schemas from data_model.zpp are in scope *)

(*---------------------------------------------------------------------------*)
(* Virtual PCB System State                                                   *)
(*---------------------------------------------------------------------------*)

(* Complete state of the Virtual PCB hardware system *)
VirtualPCBState
  device_id : DEVICE_ID
  model_number : seq CHAR
  current_state : DEVICE_STATE
  
  (* Memory subsystem *)
  sram_region : MemoryRegion
  flash_region : MemoryRegion
  periph_region : MemoryRegion
  
  (* GPIO subsystem *)
  gpio_bank : GPIOPinBank
  
  (* DMA subsystem *)
  dma_controller : DMAController
  
  (* Interrupt subsystem *)
  irq_controller : InterruptController
  
  (* Power subsystem *)
  power_mgmt : PowerManagement
  
  (* Firmware state *)
  firmware_loaded : ùîπ
  firmware_version : seq CHAR
  
  (* Runtime state *)
  uptime_microseconds : ‚Ñï
  update_cycle_ms : ‚Ñï‚ÇÅ

where
  (* Memory regions have correct base addresses and sizes *)
  sram_region.base_address = SRAM_BASE ‚àß
  sram_region.size = SRAM_SIZE ‚àß
  sram_region.region_type = sram ‚àß
  sram_region.is_writable ‚àß
  
  flash_region.base_address = FLASH_BASE ‚àß
  flash_region.size = FLASH_SIZE ‚àß
  flash_region.region_type = flash ‚àß
  
  periph_region.base_address = PERIPH_BASE ‚àß
  periph_region.size = PERIPH_SIZE ‚àß
  periph_region.region_type = peripheral ‚àß
  periph_region.is_writable ‚àß
  
  (* Memory regions are disjoint *)
  (sram_region.base_address + sram_region.size ‚â§ flash_region.base_address ‚à®
   flash_region.base_address + flash_region.size ‚â§ sram_region.base_address) ‚àß
  (sram_region.base_address + sram_region.size ‚â§ periph_region.base_address ‚à®
   periph_region.base_address + periph_region.size ‚â§ sram_region.base_address) ‚àß
  (flash_region.base_address + flash_region.size ‚â§ periph_region.base_address ‚à®
   periph_region.base_address + periph_region.size ‚â§ flash_region.base_address) ‚àß
  
  (* GPIO bank is properly initialized *)
  dom gpio_bank.pins = 0 .. 63 ‚àß
  
  (* Device state constraints *)
  (current_state = uninitialized ‚áí ¬¨firmware_loaded) ‚àß
  (current_state = running ‚à® current_state = sleeping ‚áí firmware_loaded) ‚àß
  
  (* Firmware must be loaded to FLASH region *)
  (firmware_loaded ‚áí flash_region.data ‚â† ‚àÖ) ‚àß
  
  (* Update cycle is reasonable (1-100ms) *)
  update_cycle_ms ‚â• 1 ‚àß update_cycle_ms ‚â§ 100

(*---------------------------------------------------------------------------*)
(* Financial Device State                                                     *)
(*---------------------------------------------------------------------------*)

(* State of the financial device driver and its hardware registers *)
FinancialDeviceState
  driver : FinancialDeviceDriver
  
  (* Hardware register values *)
  reg_transaction_status : ‚Ñï
  reg_balance_total : ‚Ñï
  reg_transaction_count : ‚Ñï
  reg_error_code : ERROR_CODE
  
  (* Transaction buffer in SRAM *)
  transaction_buffer_addr : ADDRESS
  transaction_buffer_size : ‚Ñï
  
  (* Pin mapping state *)
  active_account_count : ‚Ñï

where
  (* Driver must be loaded and initialized *)
  driver.is_loaded ‚àß
  driver.is_initialized ‚àß
  
  (* Register values are consistent with driver state *)
  reg_transaction_count = driver.transaction_count ‚àß
  
  (* Transaction buffer is in SRAM region *)
  transaction_buffer_addr ‚â• SRAM_BASE ‚àß
  transaction_buffer_addr + transaction_buffer_size ‚â§ SRAM_BASE + SRAM_SIZE ‚àß
  
  (* Active account count matches mapped accounts *)
  active_account_count = #{a : dom driver.account_pins | 
                           driver.account_pins(a).is_active} ‚àß
  
  (* Active accounts have non-zero balance voltage *)
  (‚àÄ a : dom driver.account_pins ‚Ä¢ 
    driver.account_pins(a).is_active ‚áí 
    driver.account_pins(a).balance_voltage > 0) ‚àß
  
  (* Total balance register is consistent *)
  reg_balance_total ‚â• 0

(*---------------------------------------------------------------------------*)
(* LLM Coprocessor State                                                      *)
(*---------------------------------------------------------------------------*)

(* State of the LLM coprocessor driver and its hardware registers *)
LLMCoprocessorState
  driver : LlamaCoprocessorDriver
  
  (* Hardware register values *)
  reg_cmd : ‚Ñï
  reg_status : ‚Ñï
  reg_prompt_addr : ADDRESS
  reg_prompt_len : ‚Ñï
  reg_n_predict : ‚Ñï
  reg_token_out : ‚Ñ§         (* Token ID, can be negative *)
  reg_token_ready : ùîπ
  reg_model_id : ‚Ñï
  reg_ctx_used : ‚Ñï
  reg_error_code : ERROR_CODE
  reg_perf_tokens_sec : ‚Ñï
  
  (* Inference state *)
  prompt_buffer : seq ‚Ñ§     (* Tokenized prompt *)
  output_tokens : seq ‚Ñ§     (* Generated tokens *)
  current_token_index : ‚Ñï
  
  (* Runtime state *)
  inference_start_time : ‚Ñï  (* Microseconds *)
  inference_end_time : ‚Ñï    (* Microseconds *)

where
  (* Driver must be loaded and initialized if model is loaded *)
  (driver.model_loaded ‚áí driver.is_loaded ‚àß driver.is_initialized) ‚àß
  
  (* Model ID register matches driver state *)
  (driver.model_loaded ‚áí reg_model_id = driver.model_id) ‚àß
  (¬¨driver.model_loaded ‚áí reg_model_id = 0) ‚àß
  
  (* Status register reflects driver state *)
  (driver.inference_active ‚áí (reg_status & (1 << STATUS_BIT_BUSY)) ‚â† 0) ‚àß
  (¬¨driver.inference_active ‚áí (reg_status & (1 << STATUS_BIT_BUSY)) = 0) ‚àß
  (driver.model_loaded ‚áí (reg_status & (1 << STATUS_BIT_MODEL_READY)) ‚â† 0) ‚àß
  
  (* Token ready flag is consistent *)
  (reg_token_ready ‚áî (reg_status & (1 << STATUS_BIT_TOKEN_READY)) ‚â† 0) ‚àß
  
  (* Prompt address is in valid SRAM region when inference active *)
  (driver.inference_active ‚áí 
    reg_prompt_addr ‚â• SRAM_BASE ‚àß 
    reg_prompt_addr + reg_prompt_len ‚â§ SRAM_BASE + SRAM_SIZE) ‚àß
  
  (* Context used is within model limits *)
  (driver.model_loaded ‚áí 
    reg_ctx_used ‚â§ driver.model_config.n_ctx) ‚àß
  
  (* Predict count is reasonable *)
  (reg_n_predict > 0 ‚àß reg_n_predict ‚â§ 2048) ‚àß
  
  (* Current token index is within output bounds *)
  current_token_index ‚â§ #output_tokens ‚àß
  
  (* Token output is valid when token ready *)
  (reg_token_ready ‚áí current_token_index > 0) ‚àß
  
  (* Timing invariants *)
  (driver.inference_active ‚áí inference_start_time > 0) ‚àß
  (¬¨driver.inference_active ‚àß inference_end_time > 0 ‚áí 
    inference_end_time ‚â• inference_start_time) ‚àß
  
  (* Performance counter is consistent with telemetry *)
  (driver.telemetry.tokens_per_second ‚â• 0 ‚áí
    reg_perf_tokens_sec = ‚åädriver.telemetry.tokens_per_second‚åã)

(*---------------------------------------------------------------------------*)
(* Complete System State                                                      *)
(*---------------------------------------------------------------------------*)

(* Top-level system state integrating all components *)
NPUSystemState
  pcb_state : VirtualPCBState
  financial_state : FinancialDeviceState
  llm_state : LLMCoprocessorState
  
  (* System-wide invariants *)
  system_initialized : ùîπ
  drivers_loaded : ùîπ
  system_error : ùîπ
  error_log : seq ERROR_CODE

where
  (* System initialization dependencies *)
  (system_initialized ‚áî 
    pcb_state.current_state ‚àà {ready, running, sleeping}) ‚àß
  
  (* Drivers loaded implies PCB is at least ready *)
  (drivers_loaded ‚áí system_initialized) ‚àß
  
  (* Both drivers must be loaded for system to be ready *)
  (drivers_loaded ‚áî 
    financial_state.driver.is_loaded ‚àß 
    llm_state.driver.is_loaded) ‚àß
  
  (* System error flag reflects component errors *)
  (system_error ‚áî 
    pcb_state.current_state = error ‚à®
    financial_state.reg_error_code ‚â† ‚àÖ ‚à®
    llm_state.reg_error_code ‚â† ‚àÖ) ‚àß
  
  (* Error log contains all component errors *)
  (financial_state.reg_error_code ‚â† ‚àÖ ‚áí 
    financial_state.reg_error_code ‚àà ran error_log) ‚àß
  (llm_state.reg_error_code ‚â† ‚àÖ ‚áí 
    llm_state.reg_error_code ‚àà ran error_log) ‚àß
  
  (* GPIO pin consistency between PCB and financial driver *)
  (‚àÄ a : dom financial_state.driver.account_pins ‚Ä¢
    let pin_num == financial_state.driver.account_pins(a).pin_number |
    let pin == pcb_state.gpio_bank.pins(pin_num) |
      (* Pin mode must be analog for financial accounts *)
      pin.mode = analog ‚àß
      (* Pin analog value corresponds to balance voltage *)
      let voltage == financial_state.driver.account_pins(a).balance_voltage |
      let adc_value == ‚åä(voltage / 3.3) * 4095‚åã |
        pin.analog_value = adc_value) ‚àß
  
  (* Peripheral memory region contains both device registers *)
  (‚àÄ addr : FIN_REG_BASE .. (FIN_REG_BASE + 0x10) |
    addr ‚àà dom pcb_state.periph_region.data) ‚àß
  (‚àÄ addr : LLM_REG_BASE .. (LLM_REG_BASE + 0x2C) |
    addr ‚àà dom pcb_state.periph_region.data) ‚àß
  
  (* Financial device registers are mapped to peripheral memory *)
  read_reg32(pcb_state.periph_region, FIN_REG_TRANSACTION_STATUS) = 
    financial_state.reg_transaction_status ‚àß
  read_reg32(pcb_state.periph_region, FIN_REG_BALANCE_TOTAL) = 
    financial_state.reg_balance_total ‚àß
  read_reg32(pcb_state.periph_region, FIN_REG_TRANSACTION_COUNT) = 
    financial_state.reg_transaction_count ‚àß
  
  (* LLM device registers are mapped to peripheral memory *)
  read_reg32(pcb_state.periph_region, LLM_REG_CMD) = llm_state.reg_cmd ‚àß
  read_reg32(pcb_state.periph_region, LLM_REG_STATUS) = llm_state.reg_status ‚àß
  read_reg32(pcb_state.periph_region, LLM_REG_PROMPT_ADDR) = llm_state.reg_prompt_addr ‚àß
  read_reg32(pcb_state.periph_region, LLM_REG_PROMPT_LEN) = llm_state.reg_prompt_len ‚àß
  read_reg32(pcb_state.periph_region, LLM_REG_N_PREDICT) = llm_state.reg_n_predict ‚àß
  read_reg32(pcb_state.periph_region, LLM_REG_MODEL_ID) = llm_state.reg_model_id ‚àß
  read_reg32(pcb_state.periph_region, LLM_REG_CTX_USED) = llm_state.reg_ctx_used ‚àß
  read_reg32(pcb_state.periph_region, LLM_REG_PERF_TOKENS_SEC) = llm_state.reg_perf_tokens_sec

(*---------------------------------------------------------------------------*)
(* Helper Functions for Register Access                                       *)
(*---------------------------------------------------------------------------*)

(* Read a 32-bit register from memory region *)
read_reg32 : MemoryRegion √ó ADDRESS ‚Üí ‚Ñï
‚àÄ region : MemoryRegion; addr : ADDRESS ‚Ä¢
  addr ‚àà dom region.data ‚àß 
  addr + 3 ‚àà dom region.data ‚áí
    read_reg32(region, addr) = 
      region.data(addr) + 
      (region.data(addr + 1) << 8) + 
      (region.data(addr + 2) << 16) + 
      (region.data(addr + 3) << 24)

(* Write a 32-bit register to memory region *)
write_reg32 : MemoryRegion √ó ADDRESS √ó ‚Ñï ‚Üí MemoryRegion
‚àÄ region : MemoryRegion; addr : ADDRESS; value : ‚Ñï ‚Ä¢
  region.is_writable ‚àß
  addr ‚àà dom region.data ‚àß 
  addr + 3 ‚àà dom region.data ‚àß
  value ‚â§ 0xFFFFFFFF ‚áí
    let region' == region |
      region'.data = region.data ‚äï {
        addr ‚Ü¶ (value & 0xFF),
        addr + 1 ‚Ü¶ ((value >> 8) & 0xFF),
        addr + 2 ‚Ü¶ ((value >> 16) & 0xFF),
        addr + 3 ‚Ü¶ ((value >> 24) & 0xFF)
      }

(*---------------------------------------------------------------------------*)
(* State Invariants                                                           *)
(*---------------------------------------------------------------------------*)

(* Global system invariants that must hold in all states *)
SystemInvariants
  NPUSystemState

where
  (* PCB device state is consistent *)
  pcb_state.current_state ‚àà DEVICE_STATE ‚àß
  
  (* Memory regions are properly initialized *)
  sram_region.region_type = sram ‚àß
  flash_region.region_type = flash ‚àß
  periph_region.region_type = peripheral ‚àß
  
  (* GPIO pins are within valid ranges *)
  (‚àÄ i : 0 .. 63 ‚Ä¢ i ‚àà dom pcb_state.gpio_bank.pins) ‚àß
  
  (* DMA transfers are bounded *)
  #pcb_state.dma_controller.active_transfers ‚â§ 8 ‚àß
  
  (* Interrupt queue is bounded *)
  #pcb_state.irq_controller.pending_queue ‚â§ 256 ‚àß
  
  (* Power rails are within spec *)
  pcb_state.power_mgmt.voltage_rails(rail_3v3) ‚â• 3.2 ‚àß
  pcb_state.power_mgmt.voltage_rails(rail_3v3) ‚â§ 3.4 ‚àß
  pcb_state.power_mgmt.voltage_rails(rail_5v0) ‚â• 4.9 ‚àß
  pcb_state.power_mgmt.voltage_rails(rail_5v0) ‚â§ 5.1 ‚àß
  
  (* Temperature is within operating range *)
  pcb_state.power_mgmt.temperature_celsius ‚â• -40 ‚àß
  pcb_state.power_mgmt.temperature_celsius ‚â§ 85 ‚àß
  
  (* Financial accounts respect double-entry accounting *)
  (‚àÄ a : dom financial_state.driver.account_pins |
    a ‚àà ASSET_PIN_RANGE ‚à® a ‚àà EXPENSE_PIN_RANGE ‚Ä¢
    (* Assets and Expenses have debit balances (positive voltage) *)
    financial_state.driver.account_pins(a).balance_voltage ‚â• 0) ‚àß
  
  (* LLM inference constraints *)
  (llm_state.driver.inference_active ‚áí
    llm_state.driver.model_loaded ‚àß
    llm_state.reg_prompt_len > 0 ‚àß
    llm_state.reg_n_predict > 0) ‚àß
  
  (* Token generation progress *)
  (llm_state.driver.inference_active ‚áí
    #llm_state.output_tokens ‚â§ llm_state.reg_n_predict) ‚àß
  
  (* Telemetry consistency *)
  llm_state.driver.telemetry.total_tokens_generated = 
    #{t : ‚Ñï | t ‚àà 1 .. llm_state.driver.telemetry.total_prompts ‚Ä¢ 
      llm_state.driver.telemetry.last_completion_tokens}

(*---------------------------------------------------------------------------*)
(* State Transition Predicates                                                *)
(*---------------------------------------------------------------------------*)

(* Predicate for valid state transitions *)
ValidStateTransition
  before : NPUSystemState
  after : NPUSystemState

where
  (* Device state transitions follow defined state machine *)
  (before.pcb_state.current_state = uninitialized ‚àß
   after.pcb_state.current_state = initializing) ‚à®
  (before.pcb_state.current_state = initializing ‚àß
   after.pcb_state.current_state ‚àà {ready, error}) ‚à®
  (before.pcb_state.current_state = ready ‚àß
   after.pcb_state.current_state ‚àà {running, shutdown}) ‚à®
  (before.pcb_state.current_state = running ‚àß
   after.pcb_state.current_state ‚àà {ready, sleeping, error, shutdown}) ‚à®
  (before.pcb_state.current_state = sleeping ‚àß
   after.pcb_state.current_state ‚àà {running, shutdown}) ‚à®
  (before.pcb_state.current_state = error ‚àß
   after.pcb_state.current_state ‚àà {ready, shutdown}) ‚àß
  
  (* Uptime only increases *)
  after.pcb_state.uptime_microseconds ‚â• 
    before.pcb_state.uptime_microseconds ‚àß
  
  (* Transaction count only increases *)
  after.financial_state.reg_transaction_count ‚â• 
    before.financial_state.reg_transaction_count ‚àß
  
  (* Total tokens generated only increases *)
  after.llm_state.driver.telemetry.total_tokens_generated ‚â• 
    before.llm_state.driver.telemetry.total_tokens_generated ‚àß
  
  (* Model cannot be unloaded while inference is active *)
  (before.llm_state.driver.inference_active ‚áí 
    after.llm_state.driver.model_loaded)

(*===========================================================================*)
(* End of System State Specification                                         *)
(*===========================================================================*)

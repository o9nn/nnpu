(*===========================================================================*)
(* Z++ Formal Specification: NPU Operations                                  *)
(* Repository: o9nn/npu                                                       *)
(* Description: Formalization of system operations for the NPU Virtual PCB   *)
(*             architecture, including device initialization, LLM inference, *)
(*             financial transactions, and hardware management.               *)
(*===========================================================================*)

(*---------------------------------------------------------------------------*)
(* Import Base Specifications                                                 *)
(*---------------------------------------------------------------------------*)

(* This specification builds upon data_model.zpp and system_state.zpp *)
(* Assumed: All types, schemas, and state definitions are in scope *)

(*---------------------------------------------------------------------------*)
(* Virtual PCB Lifecycle Operations                                           *)
(*---------------------------------------------------------------------------*)

(* Initialize the Virtual PCB hardware *)
InitializeVirtualPCB
  ŒîNPU SystemState
  device_id? : DEVICE_ID
  model_number? : seq CHAR

where
  (* Preconditions *)
  pcb_state.current_state = uninitialized ‚àß
  
  (* State transition *)
  pcb_state'.current_state = initializing ‚àß
  
  (* Device identification *)
  pcb_state'.device_id = device_id? ‚àß
  pcb_state'.model_number = model_number? ‚àß
  
  (* Initialize memory regions with zero data *)
  pcb_state'.sram_region.data = {a : SRAM_BASE .. (SRAM_BASE + SRAM_SIZE - 1) ‚Ä¢ a ‚Ü¶ 0} ‚àß
  pcb_state'.flash_region.data = ‚àÖ ‚àß  (* FLASH starts empty *)
  pcb_state'.periph_region.data = {a : PERIPH_BASE .. (PERIPH_BASE + PERIPH_SIZE - 1) ‚Ä¢ a ‚Ü¶ 0} ‚àß
  
  (* Initialize GPIO pins to default state *)
  (‚àÄ i : 0 .. 63 ‚Ä¢
    pcb_state'.gpio_bank.pins(i).mode = input ‚àß
    pcb_state'.gpio_bank.pins(i).state = low ‚àß
    pcb_state'.gpio_bank.pins(i).analog_value = 0 ‚àß
    pcb_state'.gpio_bank.pins(i).interrupt_enabled = false) ‚àß
  
  (* Initialize DMA controller *)
  pcb_state'.dma_controller.active_transfers = ‚àÖ ‚àß
  
  (* Initialize interrupt controller *)
  (‚àÄ v : 0 .. 255 ‚Ä¢
    pcb_state'.irq_controller.interrupt_table(v).enabled = false ‚àß
    pcb_state'.irq_controller.interrupt_table(v).pending = false) ‚àß
  pcb_state'.irq_controller.pending_queue = ‚ü®‚ü© ‚àß
  
  (* Initialize power management *)
  pcb_state'.power_mgmt.voltage_rails(rail_3v3) = 3.3 ‚àß
  pcb_state'.power_mgmt.voltage_rails(rail_5v0) = 5.0 ‚àß
  pcb_state'.power_mgmt.temperature_celsius = 25.0 ‚àß
  
  (* Reset uptime *)
  pcb_state'.uptime_microseconds = 0 ‚àß
  
  (* System state updates *)
  system_initialized' = false ‚àß
  drivers_loaded' = false ‚àß
  system_error' = false

(* Complete initialization and enter ready state *)
CompleteInitialization
  ŒîNPU SystemState

where
  (* Preconditions *)
  pcb_state.current_state = initializing ‚àß
  ¬¨system_error ‚àß
  
  (* State transition *)
  pcb_state'.current_state = ready ‚àß
  
  (* Mark system as initialized *)
  system_initialized' = true ‚àß
  
  (* Firmware marked as loaded if FLASH contains data *)
  pcb_state'.firmware_loaded = (pcb_state'.flash_region.data ‚â† ‚àÖ) ‚àß
  
  (* Preserve other state *)
  pcb_state'.device_id = pcb_state.device_id ‚àß
  pcb_state'.model_number = pcb_state.model_number ‚àß
  drivers_loaded' = drivers_loaded

(* Start the Virtual PCB device *)
StartVirtualPCB
  ŒîNPU SystemState

where
  (* Preconditions *)
  pcb_state.current_state = ready ‚àß
  system_initialized ‚àß
  
  (* State transition *)
  pcb_state'.current_state = running ‚àß
  
  (* All other state preserved *)
  pcb_state'.device_id = pcb_state.device_id ‚àß
  pcb_state'.gpio_bank = pcb_state.gpio_bank ‚àß
  system_initialized' = system_initialized ‚àß
  drivers_loaded' = drivers_loaded

(* Stop the Virtual PCB device *)
StopVirtualPCB
  ŒîNPU SystemState

where
  (* Preconditions *)
  pcb_state.current_state = running ‚àß
  
  (* LLM inference must not be active *)
  ¬¨llm_state.driver.inference_active ‚àß
  
  (* State transition *)
  pcb_state'.current_state = ready ‚àß
  
  (* Preserve all state *)
  pcb_state'.device_id = pcb_state.device_id ‚àß
  pcb_state'.gpio_bank = pcb_state.gpio_bank ‚àß
  system_initialized' = system_initialized ‚àß
  drivers_loaded' = drivers_loaded

(*---------------------------------------------------------------------------*)
(* Memory Operations                                                          *)
(*---------------------------------------------------------------------------*)

(* Read a byte from memory *)
ReadMemory
  ŒûNPU SystemState
  address? : ADDRESS
  value! : ‚Ñï

where
  (* Determine which region contains the address *)
  ((address? ‚â• SRAM_BASE ‚àß address? < SRAM_BASE + SRAM_SIZE ‚àß
    address? ‚àà dom pcb_state.sram_region.data ‚àß
    value! = pcb_state.sram_region.data(address?)) ‚à®
   (address? ‚â• FLASH_BASE ‚àß address? < FLASH_BASE + FLASH_SIZE ‚àß
    address? ‚àà dom pcb_state.flash_region.data ‚àß
    value! = pcb_state.flash_region.data(address?)) ‚à®
   (address? ‚â• PERIPH_BASE ‚àß address? < PERIPH_BASE + PERIPH_SIZE ‚àß
    address? ‚àà dom pcb_state.periph_region.data ‚àß
    value! = pcb_state.periph_region.data(address?))) ‚àß
  
  (* Value is a valid byte *)
  value! ‚â§ 255

(* Write a byte to memory *)
WriteMemory
  ŒîNPU SystemState
  address? : ADDRESS
  value? : ‚Ñï

where
  (* Value must be a valid byte *)
  value? ‚â§ 255 ‚àß
  
  (* Update appropriate memory region *)
  ((address? ‚â• SRAM_BASE ‚àß address? < SRAM_BASE + SRAM_SIZE ‚àß
    pcb_state'.sram_region.data = pcb_state.sram_region.data ‚äï {address? ‚Ü¶ value?}) ‚à®
   (address? ‚â• FLASH_BASE ‚àß address? < FLASH_BASE + FLASH_SIZE ‚àß
    pcb_state.flash_region.is_writable ‚àß
    pcb_state'.flash_region.data = pcb_state.flash_region.data ‚äï {address? ‚Ü¶ value?}) ‚à®
   (address? ‚â• PERIPH_BASE ‚àß address? < PERIPH_BASE + PERIPH_SIZE ‚àß
    pcb_state'.periph_region.data = pcb_state.periph_region.data ‚äï {address? ‚Ü¶ value?})) ‚àß
  
  (* Preserve other memory regions *)
  (address? ‚àà SRAM_BASE .. (SRAM_BASE + SRAM_SIZE - 1) ‚áí
    pcb_state'.flash_region = pcb_state.flash_region ‚àß
    pcb_state'.periph_region = pcb_state.periph_region) ‚àß
  (address? ‚àà FLASH_BASE .. (FLASH_BASE + FLASH_SIZE - 1) ‚áí
    pcb_state'.sram_region = pcb_state.sram_region ‚àß
    pcb_state'.periph_region = pcb_state.periph_region) ‚àß
  (address? ‚àà PERIPH_BASE .. (PERIPH_BASE + PERIPH_SIZE - 1) ‚áí
    pcb_state'.sram_region = pcb_state.sram_region ‚àß
    pcb_state'.flash_region = pcb_state.flash_region)

(*---------------------------------------------------------------------------*)
(* GPIO Operations                                                            *)
(*---------------------------------------------------------------------------*)

(* Set GPIO pin mode *)
SetGPIOMode
  ŒîNPU SystemState
  pin_number? : ‚Ñï
  mode? : PIN_MODE

where
  (* Preconditions *)
  pcb_state.current_state = running ‚àß
  pin_number? < 64 ‚àß
  
  (* Update pin mode *)
  pcb_state'.gpio_bank.pins = pcb_state.gpio_bank.pins ‚äï 
    {pin_number? ‚Ü¶ (pcb_state.gpio_bank.pins(pin_number?) | mode := mode?)} ‚àß
  
  (* Reset analog value if not in analog mode *)
  (mode? ‚â† analog ‚áí 
    pcb_state'.gpio_bank.pins(pin_number?).analog_value = 0)

(* Set GPIO pin digital state *)
SetGPIOState
  ŒîNPU SystemState
  pin_number? : ‚Ñï
  state? : PIN_STATE

where
  (* Preconditions *)
  pcb_state.current_state = running ‚àß
  pin_number? < 64 ‚àß
  pcb_state.gpio_bank.pins(pin_number?).mode ‚àà {output, input} ‚àß
  
  (* Update pin state *)
  pcb_state'.gpio_bank.pins = pcb_state.gpio_bank.pins ‚äï 
    {pin_number? ‚Ü¶ (pcb_state.gpio_bank.pins(pin_number?) | state := state?)}

(* Set GPIO pin analog value *)
SetGPIOAnalog
  ŒîNPU SystemState
  pin_number? : ‚Ñï
  analog_value? : ‚Ñï

where
  (* Preconditions *)
  pcb_state.current_state = running ‚àß
  pin_number? < 64 ‚àß
  pcb_state.gpio_bank.pins(pin_number?).mode = analog ‚àß
  analog_value? ‚â§ 4095 ‚àß
  
  (* Update analog value *)
  pcb_state'.gpio_bank.pins = pcb_state.gpio_bank.pins ‚äï 
    {pin_number? ‚Ü¶ (pcb_state.gpio_bank.pins(pin_number?) | 
                    analog_value := analog_value?)}

(* Read GPIO pin state *)
ReadGPIOPin
  ŒûNPU SystemState
  pin_number? : ‚Ñï
  mode! : PIN_MODE
  state! : PIN_STATE
  analog_value! : ‚Ñï

where
  (* Preconditions *)
  pin_number? < 64 ‚àß
  
  (* Read pin values *)
  mode! = pcb_state.gpio_bank.pins(pin_number?).mode ‚àß
  state! = pcb_state.gpio_bank.pins(pin_number?).state ‚àß
  analog_value! = pcb_state.gpio_bank.pins(pin_number?).analog_value

(*---------------------------------------------------------------------------*)
(* Financial Device Operations                                                *)
(*---------------------------------------------------------------------------*)

(* Map a financial account to a GPIO pin *)
MapAccountToPin
  ŒîFinancialDeviceState
  account_code? : ACCOUNT_CODE
  pin_number? : ‚Ñï
  success! : ùîπ

where
  (* Preconditions *)
  driver.is_initialized ‚àß
  pin_number? < 64 ‚àß
  account_code? ‚àâ dom driver.account_pins ‚àß
  
  (* Create account pin mapping *)
  let new_pin == AccountPin | 
    new_pin.account_code = account_code? ‚àß
    new_pin.pin_number = pin_number? ‚àß
    new_pin.balance_voltage = 0.0 ‚àß
    new_pin.is_active = false ‚Ä¢
  
  driver'.account_pins = driver.account_pins ‚à™ {account_code? ‚Ü¶ new_pin} ‚àß
  success! = true ‚àß
  
  (* Preserve other state *)
  driver'.transaction_count = driver.transaction_count ‚àß
  driver'.total_balance = driver.total_balance

(* Update account balance *)
UpdateAccountBalance
  ŒîFinancialDeviceState
  ŒîGPIOPinBank
  account_code? : ACCOUNT_CODE
  balance? : ‚Ñù
  success! : ùîπ

where
  (* Preconditions *)
  driver.is_initialized ‚àß
  account_code? ‚àà dom driver.account_pins ‚àß
  balance? ‚â• 0 ‚àß
  
  (* Convert balance to voltage using logarithmic scale *)
  let voltage == (log‚ÇÅ‚ÇÄ(balance? + 1) / 6.0) * 3.3 ‚Ä¢
  let pin_num == driver.account_pins(account_code?).pin_number ‚Ä¢
  let adc_value == ‚åä(voltage / 3.3) * 4095‚åã ‚Ä¢
  
  (* Update account pin mapping *)
  driver'.account_pins = driver.account_pins ‚äï 
    {account_code? ‚Ü¶ (driver.account_pins(account_code?) | 
                      balance_voltage := voltage,
                      is_active := (balance? > 0))} ‚àß
  
  (* Update corresponding GPIO pin *)
  gpio_bank'.pins = gpio_bank.pins ‚äï
    {pin_num ‚Ü¶ (gpio_bank.pins(pin_num) | 
                mode := analog,
                analog_value := adc_value)} ‚àß
  
  (* Update total balance *)
  driver'.total_balance = 
    Œ£ {a : dom driver'.account_pins ‚Ä¢ 
       (driver'.account_pins(a).balance_voltage / 3.3) * 4095} ‚àß
  
  (* Increment transaction count *)
  driver'.transaction_count = driver.transaction_count + 1 ‚àß
  
  (* Update hardware registers *)
  reg_transaction_count' = driver'.transaction_count ‚àß
  reg_balance_total' = ‚åädriver'.total_balance‚åã ‚àß
  
  success! = true

(* Read account balance *)
ReadAccountBalance
  ŒûFinancialDeviceState
  account_code? : ACCOUNT_CODE
  balance! : ‚Ñù

where
  (* Preconditions *)
  driver.is_initialized ‚àß
  account_code? ‚àà dom driver.account_pins ‚àß
  
  (* Convert voltage back to balance *)
  let voltage == driver.account_pins(account_code?).balance_voltage ‚Ä¢
  balance! = 10^((voltage / 3.3) * 6.0) - 1

(*---------------------------------------------------------------------------*)
(* LLM Coprocessor Operations                                                 *)
(*---------------------------------------------------------------------------*)

(* Load GGUF model *)
LoadModel
  ŒîLLMCoprocessorState
  model_path? : MODEL_PATH
  model_config? : LlamaModelConfig
  success! : ùîπ

where
  (* Preconditions *)
  driver.is_initialized ‚àß
  ¬¨driver.model_loaded ‚àß
  ¬¨driver.inference_active ‚àß
  
  (* Update model configuration *)
  driver'.model_config = model_config? ‚àß
  
  (* Mark model as loaded *)
  driver'.model_loaded = true ‚àß
  
  (* Assign model ID *)
  driver'.model_id > 0 ‚àß
  
  (* Update hardware registers *)
  reg_model_id' = driver'.model_id ‚àß
  reg_ctx_used' = model_config?.n_ctx ‚àß
  reg_status' = reg_status ‚à® (1 << STATUS_BIT_MODEL_READY) ‚àß
  reg_error_code' = ‚àÖ ‚àß
  
  (* Initialize telemetry *)
  driver'.telemetry.total_tokens_generated = 0 ‚àß
  driver'.telemetry.total_prompts = 0 ‚àß
  
  success! = true

(* Configure inference parameters *)
ConfigureInference
  ŒîLLMCoprocessorState
  prompt_addr? : ADDRESS
  prompt_len? : ‚Ñï
  n_predict? : ‚Ñï
  success! : ùîπ

where
  (* Preconditions *)
  driver.model_loaded ‚àß
  ¬¨driver.inference_active ‚àß
  prompt_addr? ‚â• SRAM_BASE ‚àß
  prompt_addr? + prompt_len? ‚â§ SRAM_BASE + SRAM_SIZE ‚àß
  prompt_len? > 0 ‚àß
  n_predict? > 0 ‚àß n_predict? ‚â§ 2048 ‚àß
  
  (* Update hardware registers *)
  reg_prompt_addr' = prompt_addr? ‚àß
  reg_prompt_len' = prompt_len? ‚àß
  reg_n_predict' = n_predict? ‚àß
  
  (* Clear previous output *)
  output_tokens' = ‚ü®‚ü© ‚àß
  current_token_index' = 0 ‚àß
  reg_token_ready' = false ‚àß
  
  success! = true

(* Start inference *)
StartInference
  ŒîLLMCoprocessorState
  success! : ùîπ

where
  (* Preconditions *)
  driver.model_loaded ‚àß
  ¬¨driver.inference_active ‚àß
  reg_prompt_len > 0 ‚àß
  reg_n_predict > 0 ‚àß
  
  (* Mark inference as active *)
  driver'.inference_active = true ‚àß
  
  (* Set hardware status *)
  reg_status' = (reg_status ‚à® (1 << STATUS_BIT_BUSY)) ‚àß
                ~(1 << STATUS_BIT_IDLE) ‚àß
  reg_cmd' = reg_cmd ‚à® (1 << CMD_BIT_START_INF) ‚àß
  
  (* Record start time *)
  inference_start_time' > inference_start_time ‚àß
  
  (* Increment prompt counter *)
  driver'.telemetry.total_prompts = driver.telemetry.total_prompts + 1 ‚àß
  
  success! = true

(* Generate next token *)
GenerateToken
  ŒîLLMCoprocessorState
  token_id! : ‚Ñ§
  is_eog! : ùîπ

where
  (* Preconditions *)
  driver.inference_active ‚àß
  #output_tokens < reg_n_predict ‚àß
  
  (* Generate token (abstract - actual generation by GGUF runtime) *)
  token_id! ‚àà ‚Ñ§ ‚àß
  
  (* Append to output *)
  output_tokens' = output_tokens ‚å¢ ‚ü®token_id!‚ü© ‚àß
  current_token_index' = current_token_index + 1 ‚àß
  
  (* Update hardware registers *)
  reg_token_out' = token_id! ‚àß
  reg_token_ready' = true ‚àß
  reg_status' = reg_status ‚à® (1 << STATUS_BIT_TOKEN_READY) ‚àß
  
  (* Update telemetry *)
  driver'.telemetry.total_tokens_generated = 
    driver.telemetry.total_tokens_generated + 1 ‚àß
  driver'.telemetry.last_completion_tokens = #output_tokens' ‚àß
  
  (* Check for end of generation *)
  is_eog! = (#output_tokens' ‚â• reg_n_predict)

(* Complete inference *)
CompleteInference
  ŒîLLMCoprocessorState
  completion_text! : seq CHAR

where
  (* Preconditions *)
  driver.inference_active ‚àß
  (#output_tokens ‚â• reg_n_predict ‚à® 
   (reg_cmd & (1 << CMD_BIT_SOFT_STOP)) ‚â† 0) ‚àß
  
  (* Mark inference as complete *)
  driver'.inference_active = false ‚àß
  
  (* Update hardware status *)
  reg_status' = (reg_status ‚àß ~(1 << STATUS_BIT_BUSY)) ‚à® 
                (1 << STATUS_BIT_EOG) ‚à®
                (1 << STATUS_BIT_IDLE) ‚àß
  
  (* Record end time *)
  inference_end_time' > inference_start_time ‚àß
  
  (* Calculate performance metrics *)
  let duration_sec == (inference_end_time' - inference_start_time) / 1000000.0 ‚Ä¢
  let tokens_generated == #output_tokens ‚Ä¢
  driver'.telemetry.tokens_per_second = tokens_generated / duration_sec ‚àß
  reg_perf_tokens_sec' = ‚åädriver'.telemetry.tokens_per_second‚åã ‚àß
  
  (* Detokenization produces completion text *)
  #completion_text! > 0

(* High-level inference operation (composition of above operations) *)
PerformInference
  ŒîLLMCoprocessorState
  prompt? : seq CHAR
  sequence_config? : LlamaSequenceConfig
  completion! : seq CHAR

where
  (* Execute inference pipeline *)
  ‚àÉ prompt_addr : ADDRESS; prompt_len : ‚Ñï; 
    tokens : seq ‚Ñ§; cfg_success, start_success : ùîπ ‚Ä¢
  
  (* 1. Tokenize prompt (abstract) *)
  prompt_len = #tokens ‚àß
  
  (* 2. Configure inference *)
  ConfigureInference[prompt_addr/prompt_addr?, prompt_len/prompt_len?, 
                    sequence_config?.n_predict/n_predict?, 
                    cfg_success/success!] ‚àß
  cfg_success = true ‚àß
  
  (* 3. Start inference *)
  StartInference[start_success/success!] ‚àß
  start_success = true ‚àß
  
  (* 4. Generate tokens until complete *)
  (‚àÉ i : 1 .. sequence_config?.n_predict ‚Ä¢
    GenerateToken) ‚àß
  
  (* 5. Complete and get result *)
  CompleteInference[completion!/completion_text!]

(* Reset LLM device *)
ResetLLMDevice
  ŒîLLMCoprocessorState

where
  (* Can reset at any time except during active inference *)
  ¬¨driver.inference_active ‚àß
  
  (* Reset to initial state *)
  driver'.model_loaded = false ‚àß
  driver'.model_id = 0 ‚àß
  reg_status' = 1 << STATUS_BIT_IDLE ‚àß
  reg_model_id' = 0 ‚àß
  reg_ctx_used' = 0 ‚àß
  reg_error_code' = ‚àÖ ‚àß
  output_tokens' = ‚ü®‚ü© ‚àß
  current_token_index' = 0 ‚àß
  
  (* Reset telemetry *)
  driver'.telemetry.total_tokens_generated = 0 ‚àß
  driver'.telemetry.total_prompts = 0 ‚àß
  driver'.telemetry.tokens_per_second = 0

(*---------------------------------------------------------------------------*)
(* DMA Operations                                                             *)
(*---------------------------------------------------------------------------*)

(* Start a DMA transfer *)
StartDMATransfer
  ŒîDMAController
  source? : ADDRESS
  dest? : ADDRESS
  length? : ‚Ñï‚ÇÅ
  channel! : ‚Ñï
  success! : ùîπ

where
  (* Preconditions *)
  #active_transfers < max_channels ‚àß
  source? + length? ‚â§ dest? ‚à® dest? + length? ‚â§ source? ‚àß
  
  (* Allocate channel *)
  channel! ‚àà (0 .. (max_channels - 1)) \ dom active_transfers ‚àß
  
  (* Create transfer descriptor *)
  let transfer == DMATransfer |
    transfer.channel_id = channel! ‚àß
    transfer.source_address = source? ‚àß
    transfer.dest_address = dest? ‚àß
    transfer.length = length? ‚àß
    transfer.completed = false ‚Ä¢
  
  active_transfers' = active_transfers ‚à™ {channel! ‚Ü¶ transfer} ‚àß
  success! = true

(* Check if DMA transfer is complete *)
IsDMAComplete
  ŒûDMAController
  channel? : ‚Ñï
  complete! : ùîπ

where
  channel? ‚àà dom active_transfers ‚àß
  complete! = active_transfers(channel?).completed

(*---------------------------------------------------------------------------*)
(* Error Handling Operations                                                  *)
(*---------------------------------------------------------------------------*)

(* Report system error *)
ReportError
  ŒîNPU SystemState
  error_code? : ERROR_CODE
  component? : seq CHAR

where
  (* Add error to log *)
  error_log' = error_log ‚å¢ ‚ü®error_code?‚ü© ‚àß
  
  (* Set system error flag *)
  system_error' = true ‚àß
  
  (* Update appropriate component error register *)
  (component? = "financial" ‚áí 
    financial_state'.reg_error_code = error_code?) ‚àß
  (component? = "llm" ‚áí 
    llm_state'.reg_error_code = error_code?)

(* Clear error *)
ClearError
  ŒîNPU SystemState

where
  (* Clear error flag *)
  system_error' = false ‚àß
  
  (* Clear component error registers *)
  financial_state'.reg_error_code = ‚àÖ ‚àß
  llm_state'.reg_error_code = ‚àÖ

(*===========================================================================*)
(* End of Operations Specification                                           *)
(*===========================================================================*)
